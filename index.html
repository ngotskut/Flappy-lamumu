<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover"/>
<title>Flappy Lamumu</title>
<script defer src="/_vercel/insights/script.js"></script>
<style>
  *,*::before,*::after{ box-sizing:border-box }
  :root{ --ui-bg:rgba(255,255,255,.96); --ui-radius:18px; --brand:#2563eb; }
  html,body{height:100%;margin:0}
  body{background:#6b8f99;font-family:system-ui,-apple-system,Segoe UI,Roboto,Inter,Arial,sans-serif;overflow:hidden}
  #wrap{position:fixed;inset:0}
  #game{position:absolute;inset:0;display:block;background:linear-gradient(#cfefff,#bde6fd)}
  #score{position:absolute;top:8px;left:50%;transform:translateX(-50%);font-weight:700;font-size:16px;pointer-events:none}

  #overlay{position:absolute;inset:0;background:rgba(0,0,0,.35);display:flex;align-items:center;justify-content:center;z-index:8}
  #startPanel{
    width:min(680px,92vw);background:var(--ui-bg);backdrop-filter:saturate(1.2) blur(8px);
    border-radius:var(--ui-radius);box-shadow:0 20px 60px rgba(0,0,0,.35);padding:22px 20px;z-index:9;
    text-align:center;
  }
  #startPanel h2{margin:6px 0 8px;font-size:22px}
  .muted{color:#4b5563;font-size:12px}

  #charRow{
    display:flex; gap:12px; align-items:stretch;
    overflow-x:auto; -webkit-overflow-scrolling:touch; scroll-behavior:smooth;
    padding-bottom:4px; margin-top:10px;
  }
  #charRow::-webkit-scrollbar{height:0}
  #charRow{scrollbar-width:none}

  .card{
    flex:0 0 160px;
    border:1px solid #e5e7eb;border-radius:12px;padding:10px 10px 12px;
    text-align:center;background:#fff
  }
  .card img{width:72px;height:72px;object-fit:contain;display:block;margin:4px auto 8px}

  #startPanel .card .muted{display:none!important}
  #startPanel .card div:last-child{font-size:0;line-height:1}
  #startPanel .card div:last-child input[type="radio"]{transform:scale(1.35);vertical-align:middle}

  .actions{display:flex;gap:10px;justify-content:center;margin-top:12px}
  .btn{appearance:none;border:0;border-radius:999px;padding:10px 16px;font-weight:600;background:#e5e7eb;cursor:pointer}
  .btn.primary{background:var(--brand);color:#fff}
  .btn[disabled]{opacity:.45;cursor:not-allowed}

  input[type="text"]{
    width:100%;max-width:100%;padding:12px;border:1px solid #d1d5db;border-radius:10px;background:#fff;font-size:14px
  }
  input[type="text"].invalid{border-color:#ef4444;box-shadow:0 0 0 3px rgba(239,68,68,.15)}
  #nameErr{display:none;color:#ef4444;font-size:12px;margin-top:6px}

  #lbPanel h3{font-size:16px}
  #lbList table{
    width:100%;
    border-collapse:collapse;
    table-layout:fixed;
    font-size:14px;
  }
  #lbList thead th,
  #lbList tbody td{
    padding:10px 14px;
    border-bottom:1px solid #eef2f7;
    vertical-align:middle;
    white-space:nowrap;
  }
  #lbList thead th:nth-child(1),
  #lbList tbody td:nth-child(1){
    width:52px;text-align:center;
  }
  #lbList thead th:nth-child(2),
  #lbList tbody td:nth-child(2){
    width:auto;text-align:left;
  }
  #lbList thead th:nth-child(3),
  #lbList tbody td:nth-child(3){
    width:96px;text-align:right;
    font-variant-numeric: tabular-nums;
    font-feature-settings: "tnum" 1, "lnum" 1;
  }
  #lbList thead th{background:#f6f8fb;font-weight:700}
</style>
</head>
<body>
<div id="wrap">
  <canvas id="game"></canvas>
  <div id="score">Score: 0</div>

  <div id="overlay">
    <div id="startPanel">
      <h2>Flappy Lamumu üêÆ</h2>
      <div class="muted">Tap / Click anywhere on the game to flap ¬∑ Press <b>C</b> to switch character quickly</div>

      <div style="margin:12px 0 6px">
        <input id="playerName" type="text" placeholder="Enter your name (required for leaderboard)">
        <div id="nameErr">Please enter at least 3 characters.</div>
      </div>

      <div id="charRow" aria-label="Choose character">
        <label class="card">
          <img src="assets/lamumu1.png" alt="Lamumu 1">
          <div><input type="radio" name="char" value="0" checked></div>
        </label>
        <label class="card">
          <img src="assets/lamumu2.png" alt="Lamumu 2">
          <div><input type="radio" name="char" value="1"></div>
        </label>
        <label class="card">
          <img src="assets/lamumu3.png" alt="Lamumu 3">
          <div><input type="radio" name="char" value="2"></div>
        </label>
        <label class="card">
          <img src="assets/lamumu4.png" alt="Lamumu 4">
          <div><input type="radio" name="char" value="3"></div>
        </label>
      </div>

      <div class="actions">
        <button id="btnStart" class="btn primary" disabled>Start</button>
        <button id="btnLb" class="btn" type="button">Leaderboard</button>
      </div>
      <div class="muted" style="text-align:center;margin-top:6px">Tip: You can change character during play by pressing <b>C</b>.</div>
    </div>
  </div>

  <audio id="bgm" src="assets/sweet-country-farm-music-full-354815.mp3" loop preload="auto"></audio>
  <audio id="moo" src="assets/cow-moo-390282.mp3" preload="auto"></audio>
</div>

<script>
(() => {
  /* ====== GAME & LB (tetap) ====== */
  const CHAR_SRCS = ['assets/lamumu1.png','assets/lamumu2.png','assets/lamumu3.png','assets/lamumu4.png'];
  const BONUS_SRC = 'assets/bonus.png';

  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d');
  const scoreEl = document.getElementById('score');
  const overlay = document.getElementById('overlay');
  const btnStart = document.getElementById('btnStart');
  const nameInput = document.getElementById('playerName');
  const nameErr = document.getElementById('nameErr');

  const startPanel = document.getElementById('startPanel');
  const btnLb = document.getElementById('btnLb');
  const lbPanel = document.createElement('div');
  lbPanel.id = 'lbPanel';
  lbPanel.style.marginTop = '14px';
  lbPanel.style.display = 'none';
  lbPanel.innerHTML = `
    <h3 style="margin:0 0 8px">Top 100 Leaderboard</h3>
    <div id="lbList" style="max-height:240px;overflow:auto;border:1px solid #e5e7eb;border-radius:10px;background:#fff">
      <div class="muted" style="padding:10px">Loading‚Ä¶</div>
    </div>`;
  startPanel.appendChild(lbPanel);
  const lbList = lbPanel.querySelector('#lbList');

  nameInput.value = localStorage.getItem('lamumu_name') || '';
  const MIN_NAME = 3;
  function validateName(){
    const ok = (nameInput.value.trim().length >= MIN_NAME);
    btnStart.disabled = !ok;
    nameInput.classList.toggle('invalid', !ok);
    nameErr.style.display = ok ? 'none' : 'block';
    return ok;
  }
  nameInput.addEventListener('input', validateName);
  nameInput.addEventListener('blur', validateName);
  validateName();

  let W=0,H=0,DPR=Math.max(1,Math.min(2,window.devicePixelRatio||1));
  function resize(){ W=innerWidth|0; H=innerHeight|0;
    canvas.width=(W*DPR)|0; canvas.height=(H*DPR)|0; canvas.style.width=W+'px'; canvas.style.height=H+'px';
    ctx.setTransform(DPR,0,0,DPR,0,0);
  }
  addEventListener('resize',resize,{passive:true}); resize();

  const state = {
    running:false, score:0, time:0,
    speedBase:190, speedMax:420, speed:190,
    pipesPassed:0, speedPerPipe:2.2,
    gravity:900, flapVel:-400, charIndex:0,
  };

  const pipes=[];
  const PIPE = {
    width: Math.max(80,(W*0.08)|0),
    gapBase: Math.max(160,(H*0.28)|0),
    spawnMin: Math.max(240,(W*0.36)|0),
    spawnMax: Math.max(280,(W*0.42)|0)
  };

  const bonuses=[];
  const BONUS={ sizeBase: Math.max(34,(Math.min(W,H)*0.1)|0), rotateSpeed:2.0, chance:0.65, yOffset:20 };

  const player={ x:Math.max(80,(W*0.18)|0), y:(H*0.45)|0, vy:0, r:Math.max(22,(Math.min(W,H)*0.024)|0), sprite:null };

  const charImgs = CHAR_SRCS.map(s=>{const im=new Image(); im.src=s; return im;});
  const bonusImg = new Image(); bonusImg.src=BONUS_SRC;

  function flap(){ if(state.running){ player.vy=state.flapVel; } }
  canvas.addEventListener('mousedown',flap);
  canvas.addEventListener('touchstart',e=>{e.preventDefault();flap();},{passive:false});
  addEventListener('keydown',e=>{
    if(e.code==='Space'){ e.preventDefault(); flap(); }
    if(e.key==='c'||e.key==='C'){ state.charIndex=(state.charIndex+1)%charImgs.length; player.sprite=charImgs[state.charIndex];}
  });

  btnStart.addEventListener('click',() => { if (validateName()) startGame(); });
  btnLb.addEventListener('click', openLeaderboard);

  function startGame(){
    localStorage.setItem('lamumu_name', nameInput.value.trim());
    const sel=document.querySelector('input[name="char"]:checked'); state.charIndex=sel?+sel.value:0;
    player.sprite=charImgs[state.charIndex];
    state.running=true; state.score=0; state.time=0; state.pipesPassed=0; state.speed=state.speedBase;
    player.x=Math.max(80,(W*0.18)|0); player.y=(H*0.45)|0; player.vy=0;
    pipes.length=0; bonuses.length=0;
    overlay.style.display='none';
  }

  const rand=(a,b)=>a+Math.random()*(b-a);
  const clamp=(v,min,max)=>Math.max(min,Math.min(max,v));
  function needPipe(){ if(!pipes.length) return true; const last=pipes[pipes.length-1]; return (W-last.x) >= rand(PIPE.spawnMin,PIPE.spawnMax); }
  function spawnPipe(){
    const gap=PIPE.gapBase, top=rand(50, Math.max(50,H-gap-120));
    const p={x:W+10,y:top,width:PIPE.width,gap,passed:false}; pipes.push(p);
    if(Math.random()<BONUS.chance) spawnBonusAtPipe(p);
  }
  function spawnBonusAtPipe(p){
    const mid = p.y + p.gap/2;
    const y = clamp(mid + (Math.random()-0.5)*2*BONUS.yOffset, p.y+20, p.y+p.gap-20);
    bonuses.push({x:p.x + PIPE.width + 120, y, size:BONUS.sizeBase, angle:0});
  }

  let last=performance.now();
  function loop(now){
    const dt=Math.min(0.033,(now-last)/1000); last=now;
    if(state.running) update(dt);
    draw(); requestAnimationFrame(loop);
  }
  requestAnimationFrame(loop);

  function update(dt){
    state.time+=dt;
    state.speed = Math.min(state.speedMax, state.speedBase + state.pipesPassed*state.speedPerPipe);

    if(needPipe()) spawnPipe();

    for(let i=pipes.length-1;i>=0;i--){
      const p=pipes[i]; p.x -= state.speed*dt;
      if(p.x + p.width < -10) pipes.splice(i,1);
      if(!p.passed && p.x + p.width < player.x){ p.passed=true; state.pipesPassed++; state.score += 1; }
    }

    player.vy += state.gravity*dt; player.y += player.vy*dt;

    for(const p of pipes){
      if(circleRect(player.x,player.y,player.r, p.x,0,p.width,p.y) ||
         circleRect(player.x,player.y,player.r, p.x,p.y+p.gap,p.width,H-(p.y+p.gap))){ return gameOver(); }
    }
    if(player.y>H-2 || player.y<-20) return gameOver();

    for(let i=bonuses.length-1;i>=0;i--){
      const b=bonuses[i]; b.x -= state.speed*dt; b.angle += BONUS.rotateSpeed*dt;
      if(dist(player.x,player.y,b.x,b.y) < (player.r + b.size*0.5*0.8)){ state.score += 100; bonuses.splice(i,1); continue; }
      if(b.x < -80) bonuses.splice(i,1);
    }

    scoreEl.textContent='Score: '+state.score;

    /* ===== parallax awan (untuk procedural BG) ===== */
    lastDt = dt;
    cloudOffset1 = (cloudOffset1 + state.speed * BG_PARALLAX * 0.50 * dt) % W;
    cloudOffset2 = (cloudOffset2 + state.speed * BG_PARALLAX * 0.25 * dt) % W;
  }

  async function gameOver(){
    state.running=false;
    overlay.style.display='flex';
    validateName();
    try { const moo = document.getElementById('moo'); moo.currentTime = 0; await moo.play(); } catch(_) {}
    try{ await saveScore((nameInput.value||'').trim(), state.score); }catch(e){ console.warn(e); }
    openLeaderboard();
  }

  async function saveScore(name, score){
    if(!name || name.length<3) return;
    await fetch('/api/leaderboard/submit', {
      method:'POST',
      headers:{'Content-Type':'application/json'},
      body: JSON.stringify({ name, score })
    });
  }

  async function openLeaderboard(){
    lbPanel.style.display='block';
    lbList.innerHTML = '<div class="muted" style="padding:10px">Loading‚Ä¶</div>';
    try{
      const res = await fetch('/api/leaderboard/top?limit=100');
      const data = await res.json();
      const items = (Array.isArray(data?.items) ? data.items : data)
        .filter(it => Number(it.score||0) > 0);
      renderLeaderboard(items);
    }catch(e){
      lbList.innerHTML = '<div class="muted" style="padding:10px">Cannot load leaderboard.</div>';
      console.warn('load leaderboard failed:', e);
    }
  }

  function renderLeaderboard(items){
    if(!items || !items.length){
      lbList.innerHTML = '<div class="muted" style="padding:10px">No scores yet.</div>';
      return;
    }
    const rows = items.map((it,i)=>`
      <tr>
        <td>${i+1}</td>
        <td>${escapeHtml(it.name||'anonymous')}</td>
        <td>${Number(it.score||0)}</td>
      </tr>
    `).join('');
    lbList.innerHTML = `
      <table>
        <thead>
          <tr>
            <th>#</th><th>Name</th><th>Score</th>
          </tr>
        </thead>
        <tbody>${rows}</tbody>
      </table>`;
  }

  /* =================== Procedural Background (tetap) =================== */
  const USE_PROCEDURAL_BG = true;
  const BG_CYCLE_MS = 10000;
  const BG_FADE_MS  = 1500;
  const BG_PARALLAX = 0.15;

  let currentBgIndex = 0;
  let lastDt = 1/60;
  let bgFadeMsLeft = 0;
  let bgNextIndex  = 0;
  let cloudOffset1 = 0, cloudOffset2 = 0;

  const phases = [
    { name:'morning', sky:['#FFEDD5','#FDE68A'], sunY:0.35, moon:false, stars:0 },
    { name:'day',     sky:['#BEE3F8','#90CDF4'], sunY:0.22, moon:false, stars:0 },
    { name:'dusk',    sky:['#FECACA','#FBCFE8'], sunY:0.45, moon:false, stars:20 },
    { name:'night',   sky:['#0F172A','#1E293B'], sunY:0.80, moon:true,  stars:80 },
  ];

  const STARS = Array.from({length:120}, () => ({
    x: Math.random(), y: Math.random()*0.6, tw: 0.5 + Math.random()*0.5
  }));

  setInterval(() => {
    bgNextIndex  = (currentBgIndex + 1) % phases.length;
    bgFadeMsLeft = BG_FADE_MS;
  }, BG_CYCLE_MS);

  function lerp(a,b,t){ return a+(b-a)*t; }
  function lerpColor(c1,c2,t){
    const p = n => parseInt(n,16);
    const [r1,g1,b1] = [p(c1.slice(1,3)),p(c1.slice(3,5)),p(c1.slice(5,7))];
    const [r2,g2,b2] = [p(c2.slice(1,3)),p(c2.slice(3,5)),p(c2.slice(5,7))];
    return `rgb(${(r1+(r2-r1)*t)|0},${(g1+(g2-g1)*t)|0},${(b1+(b2-b1)*t)|0})`;
  }
  function drawGradientSky(topColor, bottomColor){
    const g = ctx.createLinearGradient(0,0,0,H);
    g.addColorStop(0, topColor); g.addColorStop(1, bottomColor);
    ctx.fillStyle = g; ctx.fillRect(0,0,W,H);
  }
  function drawSun(xNorm, yNorm, alpha=1){
    const R = Math.min(W,H)*0.08;
    ctx.save(); ctx.globalAlpha = alpha; ctx.fillStyle = '#FFD166';
    ctx.beginPath(); ctx.arc(xNorm*W, yNorm*H, R, 0, Math.PI*2); ctx.fill(); ctx.restore();
  }
  function drawMoon(xNorm, yNorm, alpha=1){
    const R = Math.min(W,H)*0.06;
    ctx.save(); ctx.globalAlpha = alpha; ctx.fillStyle = '#E2E8F0';
    ctx.beginPath(); ctx.arc(xNorm*W, yNorm*H, R, 0, Math.PI*2); ctx.fill();
    ctx.globalAlpha = alpha*0.25; ctx.fillStyle = '#94A3B8';
    for(let i=0;i<5;i++){
      const r = R*(0.1+Math.random()*0.18), a = Math.random()*Math.PI*2, rr = R*0.55;
      const cx = xNorm*W + Math.cos(a)*rr, cy = yNorm*H + Math.sin(a)*rr;
      ctx.beginPath(); ctx.arc(cx,cy,r,0,Math.PI*2); ctx.fill();
    }
    ctx.restore();
  }
  function drawStars(alpha=1){
    ctx.save(); ctx.globalAlpha = alpha; ctx.fillStyle = '#E5E7EB';
    for(const s of STARS){
      const tw = 0.6 + Math.sin(performance.now()/400 * s.tw)*0.4;
      ctx.globalAlpha = alpha*tw; ctx.fillRect(s.x*W, s.y*H, 2, 2);
    }
    ctx.restore();
  }
  function drawClouds(offset1, offset2, alpha=1){
    ctx.save(); ctx.globalAlpha = alpha;
    const baseY1 = H*0.18, baseY2 = H*0.28;
    const cloud = (x,y,s) => {
      ctx.beginPath(); ctx.fillStyle='rgba(255,255,255,0.85)';
      ctx.arc(x, y, s, 0, Math.PI*2);
      ctx.arc(x+s*0.8, y+ s*0.2, s*0.9, 0, Math.PI*2);
      ctx.arc(x-s*0.7, y+ s*0.25, s*0.75, 0, Math.PI*2);
      ctx.fill();
    };
    for(let i=-1;i<=4;i++){
      const x = ((i*0.35*W) + (offset1%W));
      cloud(x, baseY1, Math.min(W,H)*0.07);
    }
    ctx.globalAlpha = alpha*0.8;
    for(let i=-1;i<=4;i++){
      const x = ((i*0.5*W) + (offset2%W));
      cloud(x, baseY2, Math.min(W,H)*0.055);
    }
    ctx.restore();
  }

  /* =================== BRICK PIPES (baru) =================== */

  // buat pola bata sekali (tanpa gambar eksternal)
  let brickPattern = null;
  function createBrickPattern(){
    const oc = document.createElement('canvas');
    const mortar = 3;          // ketebalan nat
    const brickW = 36;         // lebar 1 bata
    const brickH = 18;         // tinggi 1 bata
    oc.width  = brickW*2;      // dua kolom utk offset baris
    oc.height = brickH;
    const o = oc.getContext('2d');

    // dasar bata
    o.fillStyle = '#8B5A3C';           // coklat bata
    o.fillRect(0,0,oc.width,oc.height);

    // sedikit gradasi / noise halus
    const grd = o.createLinearGradient(0,0,0,oc.height);
    grd.addColorStop(0,'rgba(255,255,255,0.06)');
    grd.addColorStop(1,'rgba(0,0,0,0.08)');
    o.fillStyle = grd;
    o.fillRect(0,0,oc.width,oc.height);

    // garis nat (horizontal)
    o.fillStyle = '#E7DED7';
    o.fillRect(0, brickH-mortar, oc.width, mortar);

    // garis nat (vertikal) ‚Äì kolom 1
    o.fillRect(brickW-mortar, 0, mortar, brickH);
    // kolom 2 (offset setengah bata)
    o.fillRect(oc.width-mortar, 0, mortar, brickH);

    brickPattern = ctx.createPattern(oc, 'repeat');
  }
  createBrickPattern();

  function roundRectPath(x,y,w,h,r=10){
    const rr = Math.min(r, Math.abs(w)/2, Math.abs(h)/2);
    ctx.beginPath();
    ctx.moveTo(x+rr, y);
    ctx.arcTo(x+w, y, x+w, y+h, rr);
    ctx.arcTo(x+w, y+h, x, y+h, rr);
    ctx.arcTo(x, y+h, x, y, rr);
    ctx.arcTo(x, y, x+w, y, rr);
    ctx.closePath();
  }

  function fillBrickRect(x,y,w,h){
    if (w<=0 || h<=0) return;
    ctx.save();
    roundRectPath(x,y,w,h,10);
    ctx.clip();

    // isi bata
    ctx.fillStyle = brickPattern || '#8B5A3C';
    ctx.fillRect(x,y,w,h);

    // tebal border agar pipa terlihat menonjol
    ctx.lineWidth = 2;
    ctx.strokeStyle = 'rgba(0,0,0,0.25)';
    roundRectPath(x,y,w,h,10);
    ctx.stroke();

    ctx.restore();
  }

  /* =================== DRAW =================== */
  function draw(){
    ctx.clearRect(0,0,W,H);

    // procedural background
    const BG_ENABLED = USE_PROCEDURAL_BG;
    if (BG_ENABLED){
      let tFade = 0;
      if (bgFadeMsLeft > 0){
        tFade = 1 - (bgFadeMsLeft / BG_FADE_MS);
        bgFadeMsLeft = Math.max(0, bgFadeMsLeft - lastDt*1000);
      }
      const cur = phases[currentBgIndex];
      const nxt = phases[(currentBgIndex + (tFade>0 ? 1 : 0)) % phases.length];

      const skyTop = tFade ? lerpColor(cur.sky[0], nxt.sky[0], tFade) : cur.sky[0];
      const skyBot = tFade ? lerpColor(cur.sky[1], nxt.sky[1], tFade) : cur.sky[1];
      drawGradientSky(skyTop, skyBot);

      const dayX = ( (performance.now()/1000) * 0.03 ) % 2;
      const xNorm = dayX>1 ? 2-dayX : dayX;
      const yNorm = tFade ? lerp(cur.sunY, nxt.sunY, tFade) : cur.sunY;

      const showStars = (cur.stars>0 || (tFade && nxt.stars>0));
      if (showStars){
        const aCur = cur.stars>0 ? (tFade? (1-tFade) : 1) : 0;
        const aNxt = nxt.stars>0 ? tFade : 0;
        if (aCur>0) drawStars(aCur);
        if (aNxt>0) drawStars(aNxt);
      }

      const curMoon = cur.moon ? (tFade? (1-tFade):1) : 0;
      const nxtMoon = nxt.moon ? tFade : 0;
      const curSun  = !cur.moon ? (tFade? (1-tFade):1) : 0;
      const nxtSun  = !nxt.moon ? tFade : 0;
      if (curSun>0) drawSun(xNorm, yNorm, curSun);
      if (nxtSun>0) drawSun(xNorm, yNorm, nxtSun);
      if (curMoon>0) drawMoon(1-xNorm, yNorm, curMoon);
      if (nxtMoon>0) drawMoon(1-xNorm, yNorm, nxtMoon);

      drawClouds(cloudOffset1, cloudOffset2, 1);

      if (tFade===0 && bgFadeMsLeft===0 && bgNextIndex!==0 && currentBgIndex!==bgNextIndex){
        currentBgIndex = bgNextIndex;
      }
    }

    /* ===== Pipes => brick ===== */
    for(const p of pipes){
      fillBrickRect(p.x, 0, p.width, p.y);
      fillBrickRect(p.x, p.y + p.gap, p.width, H - (p.y + p.gap));
    }

    // bonuses
    for(const b of bonuses){
      ctx.save(); ctx.translate(b.x,b.y); ctx.rotate(b.angle);
      const s=b.size; if(bonusImg.complete) ctx.drawImage(bonusImg,-s/2,-s/2,s,s);
      else { ctx.fillStyle='#ff3b3b'; ctx.beginPath(); ctx.arc(0,0,s/2,0,Math.PI*2); ctx.fill(); }
      ctx.restore();
    }

    // player
    if (state.running) {
      const s = player.r*2.2*1.15;
      if (player.sprite && player.sprite.complete) {
        ctx.drawImage(player.sprite, player.x - s/2, player.y - s/2, s, s);
      } else {
        ctx.fillStyle = '#fff';
        ctx.beginPath(); ctx.arc(player.x, player.y, player.r, 0, Math.PI*2); ctx.fill();
        ctx.strokeStyle = '#111'; ctx.lineWidth = 2; ctx.stroke();
      }
    }
  } /* end draw */

  /* ======= HELPERS ======= */
  function circleRect(cx,cy,cr, rx,ry,rw,rh){
    const tx=Math.max(rx,Math.min(cx,rx+rw)), ty=Math.max(ry,Math.min(cy,ry+rh));
    const dx=cx-tx, dy=cy-ty; return dx*dx+dy*dy <= cr*cr;
  }
  function dist(x1,y1,x2,y2){ const dx=x1-x2, dy=y1-y2; return Math.hypot(dx,dy); }
  function escapeHtml(s){ return (s+'').replace(/[&<>"']/g,c=>({ '&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;' }[c])); }

  /* === Drag-to-scroll karakter === */
  const charRow = document.getElementById('charRow');
  let isDown=false,startX=0,startLeft=0, dragged=false;
  const onDown = (x)=>{ isDown=true; dragged=false; startX=x; startLeft=charRow.scrollLeft; };
  const onMove = (x)=>{ if(!isDown) return; const dx = x - startX; if(Math.abs(dx)>5) dragged=true; charRow.scrollLeft = startLeft - dx; };
  const onUp = ()=>{ isDown=false; if(dragged){ const radios = charRow.querySelectorAll('input[type="radio"]'); radios.forEach(r=>{ r.addEventListener('click', e=>{ e.stopPropagation(); e.preventDefault(); }, {once:true,capture:true}); }); } };
  charRow.addEventListener('mousedown',e=>onDown(e.pageX));
  window.addEventListener('mousemove',e=>onMove(e.pageX));
  window.addEventListener('mouseup',onUp);
  charRow.addEventListener('touchstart',e=>onDown(e.touches[0].pageX),{passive:true});
  charRow.addEventListener('touchmove',e=>onMove(e.touches[0].pageX),{passive:true});
  charRow.addEventListener('touchend',onUp);

  /* === BGM unlock === */
  const bgm = document.getElementById('bgm');
  if(bgm){
    bgm.volume = 0.35;
    let started = false;
    function unlockBgm(){ if(!started){ bgm.play().then(()=>{ started = true; }).catch(()=>{}); } }
    window.addEventListener('touchstart', unlockBgm, { once:true, passive:true });
    window.addEventListener('mousedown',   unlockBgm, { once:true, passive:true });
    window.addEventListener('keydown',     unlockBgm, { once:true, passive:true });
  }
})();
</script>
</body>
</html>
