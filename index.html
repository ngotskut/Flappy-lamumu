<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
<title>Flappy Lamumu üêÑ</title>
<style>
  :root{
    --bg:#7fa7af;          /* page background outside game */
    --card:#ffffff;
    --shadow:0 10px 30px rgba(0,0,0,.18);
    --blue:#1949bd;
  }
  html,body{height:100%;margin:0;background:var(--bg);font-family:system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,'Helvetica Neue',Arial,sans-serif}
  /* game area fills screen */
  #wrap{position:fixed;inset:0;display:grid;place-items:center}
  canvas{display:block;width:100vw;height:100vh;background:linear-gradient(#bfeeff,#b2e1f7)}
  /* top score text */
  #hud{position:fixed;top:8px;left:0;right:0;text-align:center;font-weight:700;font-size:14px;color:#111;user-select:none;pointer-events:none;}
  /* overlay (start) */
  .overlay{
    position:fixed;left:0;right:0;bottom:0;background:var(--card);
    margin:0 auto 0;max-width:min(680px,94vw);
    border-radius:16px 16px 0 0;padding:18px 18px 22px;
    box-shadow:var(--shadow);z-index:20;
  }
  .title{font-size:22px;font-weight:800;text-align:center;margin:2px 0 8px;}
  .sub{font-size:14px;color:#555;text-align:center;margin-bottom:10px}
  .grid{display:grid;gap:14px;grid-template-columns:repeat(4,1fr);margin:12px 0}
  .card{
    border:1px solid #e5e7eb;border-radius:12px;padding:10px;text-align:center
  }
  .card img{width:72px;height:72px;object-fit:contain;image-rendering:auto}
  .row{display:flex;gap:8px;align-items:center;justify-content:center;margin-top:6px}
  .actions{display:flex;gap:10px;justify-content:center;margin-top:12px}
  button{border:0;border-radius:999px;padding:10px 16px;font-weight:700;cursor:pointer}
  .primary{background:#2563eb;color:#fff}
  .ghost{background:#eef2ff;color:#1f2937}
  input[type="text"]{
    width:100%;padding:10px 12px;border-radius:10px;border:1px solid #e5e7eb;font-size:14px
  }
  .tip{font-size:12px;color:#6b7280;text-align:center;margin-top:8px}
  @media (min-width:900px){
    .overlay{border-radius:20px;padding:20px 22px;bottom:auto;top:50%;transform:translateY(-50%)}
  }
</style>
</head>
<body>
<div id="wrap">
  <canvas id="game"></canvas>
</div>
<div id="hud">Score: <span id="scoreText">0</span></div>

<!-- START OVERLAY -->
<div id="startOverlay" class="overlay">
  <div class="title">Flappy Lamumu üêÑ</div>
  <div class="sub">Tap / Click anywhere to flap ¬∑ Press <b>C</b> to switch character quickly</div>
  <input id="playerName" type="text" placeholder="Enter your name" autocomplete="off" />
  <div class="grid" style="margin-top:12px">
    <label class="card">
      <img src="assets/Lamumu1.png" alt="Lamumu #1">
      <div class="row"><input type="radio" name="skin" value="0" checked> Use #1</div>
    </label>
    <label class="card">
      <img src="assets/Lamumu2.png" alt="Lamumu #2">
      <div class="row"><input type="radio" name="skin" value="1"> Use #2</div>
    </label>
    <label class="card">
      <img src="assets/Lamumu3.png" alt="Lamumu #3">
      <div class="row"><input type="radio" name="skin" value="2"> Use #3</div>
    </label>
    <label class="card">
      <img src="assets/Lamumu4.png" alt="Lamumu #4">
      <div class="row"><input type="radio" name="skin" value="3"> Use #4</div>
    </label>
  </div>
  <div class="actions">
    <button id="startBtn" class="primary">Start</button>
    <button id="lbBtn" class="ghost" title="Coming soon">Leaderboard (coming soon)</button>
  </div>
  <div class="tip">Tip: You can change character during play by pressing <b>C</b>.</div>
</div>

<!-- AUDIO -->
<audio id="bgm" src="assets/sweet-country-farm-music-full-354815.mp3" loop preload="auto"></audio>
<audio id="sfxOver" src="assets/cow-moo-390282.mp3" preload="auto"></audio>

<script>
(()=>{
// ==================== CONFIG (speed-only difficulty) ====================
const CONFIG = {
  // physics
  gravity: 0.28,           // slightly lighter fall
  flapImpulse: -6.2,       // slightly higher flap

  // pipes (fixed gap & spacing)
  pipeGap: 240,
  pipeSpacing: 340,
  pipeWidth: 90,

  // speeds
  startSpeed: 2.0,
  maxSpeed:   3.8,
  difficulty: { stepScore: 50, stepPct: 0.10 },
  easyPipesCount: 4,

  // bonus coin
  bonus: {
    value: 100,
    spawnEveryMs: [6000, 9000],
    yClampMin: 0.18,
    yClampMax: 0.82,
    size: 36,
    spinSpeed: 1.8 // rad/s
  },

  // cow
  cowSize: 54,           // displayed size in px
  cowX:   110            // x-position
};

// ==================== helpers ====================
const clamp01 = v=>Math.max(0,Math.min(1,v));
const lerp=(a,b,t)=>a+(b-a)*t;
function getCurrentSpeed(score, pipesPassed){
  if(pipesPassed < CONFIG.easyPipesCount) return CONFIG.startSpeed;
  const steps = Math.floor(score/CONFIG.difficulty.stepScore);
  const t = clamp01(steps*CONFIG.difficulty.stepPct);
  return lerp(CONFIG.startSpeed, CONFIG.maxSpeed, t);
}
function randRange(a,b){return a + Math.random()*(b-a)}

// ==================== DOM ====================
const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');
const scoreText = document.getElementById('scoreText');
const startOverlay = document.getElementById('startOverlay');
const playerNameInput = document.getElementById('playerName');
const startBtn  = document.getElementById('startBtn');
const lbBtn     = document.getElementById('lbBtn');
const bgm = document.getElementById('bgm');
const sfxOver = document.getElementById('sfxOver');

let W=innerWidth, H=innerHeight;
function resize(){ W=innerWidth; H=innerHeight; canvas.width=W; canvas.height=H; }
addEventListener('resize', resize, {passive:true}); resize();

// unlock audio on first user gesture
const unlock = ()=>{ [bgm,sfxOver].forEach(a=>{ try{a.muted=false; a.play().then(()=>a.pause()).catch(()=>{});}catch{} }); 
  removeEventListener('pointerdown', unlock); removeEventListener('click', unlock);
};
addEventListener('pointerdown', unlock, {once:true}); addEventListener('click', unlock, {once:true});

// ==================== assets ====================
const cowImgs = [new Image(), new Image(), new Image(), new Image()];
cowImgs[0].src = 'assets/Lamumu1.png';
cowImgs[1].src = 'assets/Lamumu2.png';
cowImgs[2].src = 'assets/Lamumu3.png';
cowImgs[3].src = 'assets/Lamumu4.png';
const bonusImg = new Image(); bonusImg.src='assets/bonus.png';

// ==================== game state ====================
let running=false, gameOver=false;
let score=0, best=0;
let pipes=[]; // each: {x, gapY}
let pipesPassed=0;
let pipeSpeed = CONFIG.startSpeed;

let cowY = H*0.4, velY = 0, skin=0, name='';
let nextPipeX = W + 300; // where to spawn next
let bonus=null; // {x,y,angle}
let nextBonusAt = 0;

// ==================== input ====================
addEventListener('pointerdown', ()=>{ if(running && !gameOver) flap(); });
addEventListener('keydown', e=>{
  if(e.code==='Space'){ e.preventDefault(); if(running && !gameOver) flap(); }
  if(e.key==='c' || e.key==='C'){ if(running && !gameOver){ skin=(skin+1)%cowImgs.length; } }
});

// ==================== start/restart ====================
startBtn.addEventListener('click', ()=>{
  name = playerNameInput.value.trim().slice(0,24) || 'Player';
  const picked = document.querySelector('input[name="skin"]:checked');
  skin = picked ? parseInt(picked.value,10):0;
  startOverlay.style.display='none';
  startGame();
});

function startGame(){
  score=0; scoreText.textContent='0';
  pipes=[]; pipesPassed=0; pipeSpeed=CONFIG.startSpeed;
  cowY=H*0.4; velY=0; gameOver=false; running=true;
  nextPipeX = W + 200;
  scheduleNextBonus();
  bgm.currentTime=0; bgm.volume=.6; bgm.play().catch(()=>{});
}

// ==================== core mechanics ====================
function flap(){ velY = CONFIG.flapImpulse; }

function spawnPipe(){
  // choose a center Y that keeps the gap entirely on-screen
  const safeMargin = 60;
  const minCenter = safeMargin + CONFIG.pipeGap/2;
  const maxCenter = H - safeMargin - CONFIG.pipeGap/2;
  const centerY = randRange(minCenter, maxCenter);
  pipes.push({ x: W + 20, gapY: centerY });
}

function scheduleNextBonus(){
  const min = CONFIG.bonus.spawnEveryMs[0];
  const max = CONFIG.bonus.spawnEveryMs[1];
  nextBonusAt = performance.now() + randRange(min, max);
}

function maybeSpawnBonus(t){
  if(bonus || t < nextBonusAt) return;
  const minY = H * CONFIG.bonus.yClampMin;
  const maxY = H * CONFIG.bonus.yClampMax;
  bonus = {
    x: W + 80,
    y: randRange(minY, maxY),
    angle: 0
  };
}

function update(dt){
  if(!running || gameOver) return;

  // physics
  velY += CONFIG.gravity;
  cowY += velY;

  // speed progression
  pipeSpeed = getCurrentSpeed(score, pipesPassed);

  // spawn pipes by spacing
  if(pipes.length===0){
    spawnPipe(); nextPipeX = W + CONFIG.pipeSpacing;
  }else{
    // ensure a new pipe appears when last one is far enough
    if(pipes[pipes.length-1].x < W - CONFIG.pipeSpacing){
      spawnPipe();
    }
  }

  // move pipes & scoring & collision
  for(let i=pipes.length-1;i>=0;i--){
    const p = pipes[i];
    p.x -= pipeSpeed;

    // draw handled in render()

    // passed check (middle of gap)
    const passX = p.x + CONFIG.pipeWidth/2;
    if(!p.passed && passX < CONFIG.cowX){
      p.passed = true;
      score += 1;
      scoreText.textContent = String(score);
      pipesPassed += 1;
    }

    // remove off-screen
    if(p.x + CONFIG.pipeWidth < -20){
      pipes.splice(i,1);
    }

    // collision check with cow
    const cx = CONFIG.cowX, cy = cowY, half = CONFIG.cowSize*0.38;
    const inPipeX = (cx+half) > p.x && (cx-half) < (p.x+CONFIG.pipeWidth);
    if(inPipeX){
      const topBottomClear = (cy-half) > (p.gapY - CONFIG.pipeGap/2) &&
                             (cy+half) < (p.gapY + CONFIG.pipeGap/2);
      if(!topBottomClear){
        doGameOver();
      }
    }
  }

  // floor / ceiling collision
  const margin = CONFIG.cowSize*0.5;
  if(cowY > H - margin || cowY < margin){
    doGameOver();
  }

  // bonus spawn & update
  const now = performance.now();
  maybeSpawnBonus(now);
  if(bonus){
    bonus.x -= pipeSpeed;
    bonus.angle += CONFIG.bonus.spinSpeed * (dt/1000);
    // pickup?
    const dx = (CONFIG.cowX - bonus.x);
    const dy = (cowY - bonus.y);
    const dist2 = dx*dx + dy*dy;
    const r = (CONFIG.cowSize*0.45 + CONFIG.bonus.size*0.5);
    if(dist2 < r*r){
      score += CONFIG.bonus.value;
      scoreText.textContent = String(score);
      bonus = null;
      scheduleNextBonus();
    }else if(bonus.x < -60){
      bonus = null;
      scheduleNextBonus();
    }
  }
}

function doGameOver(){
  if(gameOver) return;
  gameOver = true; running=false;
  bgm.pause();
  try{ sfxOver.currentTime=0; sfxOver.play().catch(()=>{});}catch{}
  // show start overlay again after short delay
  setTimeout(()=>{ startOverlay.style.display='block'; }, 500);
}

// ==================== render ====================
function render(){
  // background is already gradient by CSS; we can draw subtle sky tint if needed
  ctx.clearRect(0,0,W,H);

  // pipes
  ctx.fillStyle = '#1f4ed8';
  for(const p of pipes){
    const x = p.x, w = CONFIG.pipeWidth;
    const gapH = CONFIG.pipeGap;
    const topH = p.gapY - gapH/2;
    const botY = p.gapY + gapH/2;
    ctx.fillRect(x, 0, w, Math.max(0, topH));
    ctx.fillRect(x, botY, w, H - botY);
  }

  // bonus
  if(bonus){
    const s = CONFIG.bonus.size;
    const x = bonus.x, y = bonus.y, a = bonus.angle;
    if(bonusImg.complete && bonusImg.naturalWidth){
      ctx.save();
      ctx.translate(x, y);
      ctx.rotate(a);
      ctx.drawImage(bonusImg, -s/2, -s/2, s, s);
      ctx.restore();
    }else{
      // fallback: colored rotating disc
      ctx.save(); ctx.translate(x,y); ctx.rotate(a);
      ctx.fillStyle='#000'; ctx.beginPath(); ctx.arc(0,0,s*0.5,0,Math.PI*2); ctx.fill();
      ctx.restore();
    }
  }

  // cow
  const img = cowImgs[skin];
  const size = CONFIG.cowSize;
  if(img.complete && img.naturalWidth){
    ctx.drawImage(img, CONFIG.cowX - size/2, cowY - size/2, size, size);
  }else{
    // fallback box
    ctx.fillStyle='#222';
    ctx.fillRect(CONFIG.cowX - size/2, cowY - size/2, size, size);
  }
}

// ==================== main loop ====================
let last = performance.now();
function loop(now){
  const dt = now - last; last = now;
  update(dt);
  render();
  requestAnimationFrame(loop);
}
requestAnimationFrame(loop);

// ==================== pointer capture note ====================
// Keep overlay clickable; when overlay is visible, canvas is still behind it,
// but overlay sits above it (higher z-index). Inputs are naturally tappable.
})();
</script>
</body>
</html>
